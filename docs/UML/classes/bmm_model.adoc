=== BMM_MODEL Class

[cols="^1,3,5"]
|===
h|*Class*
2+^h|*BMM_MODEL*

h|*Description*
2+a|Definition of the root of a BMM model (along with what is inherited from `BMM_SCHEMA_CORE`).

h|*Inherit*
2+|`BMM_MODEL_CORE`, `BMM_PACKAGE_CONTAINER`

h|*Attributes*
^h|*Signature*
^h|*Meaning*

h|*0..1*
|*class_definitions*: `Hash<String,BMM_CLASS>`
a|All classes in this schema, keyed by type name.
h|*Functions*
^h|*Signature*
^h|*Meaning*

h|
|*class_definition* ( +
a_name: `String[1]` +
): `BMM_CLASS`
a|Retrieve the class definition corresponding to `_a_type_name_` (which may contain a generic part).

h|
|*primitive_types* (): `List<String>`
a|List of keys in `_class_definitions_` of items marked as primitive types, as defined in input schema.

h|
|*enumeration_types* (): `List<String>`
a|List of keys in `_class_definitions_` of items that are enumeration types, as defined in input schema.

h|
|*enumeration_definition* ( +
a_name: `String[1]` +
): `BMM_ENUMERATION`
a|Retrieve the enumeration definition corresponding to `_a_type_name_`.

h|
|*property_definition* (): `BMM_PROPERTY`
a|Retrieve the property definition for `_a_prop_name_` in flattened class corresponding to `_a_type_name_`.

h|
|*ms_conformant_property_type* ( +
a_bmm_type_name: `String[1]`, +
a_bmm_property_name: `String[1]`, +
a_ms_property_name: `String[1]` +
): `Boolean`
a|True if `_a_ms_property_type_` is a valid 'MS' dynamic type for `_a_property_` in BMM type `_a_bmm_type_name_`. 'MS' conformance means 'model-semantic' conformance, which abstracts away container types like `List<>`, `Set<>` etc and compares the dynamic type with the relation target type in the UML sense, i.e. regardless of whether there is single or multiple containment.

h|
|*property_definition_at_path* (): `BMM_PROPERTY`
a|Retrieve the property definition for `_a_property_path_` in flattened class corresponding to `_a_type_name_`.

h|
|*all_ancestor_classes* ( +
a_class: `String[1]` +
): `List<String>`
a|Return all ancestor types of `_a_class_name_` up to root class (usually `Any`, `Object` or something similar). Does  not include current class. Returns empty list if none.

h|
|*type_conforms_to* ( +
a_desc_type: `String[1]`, +
an_anc_type: `String[1]` +
): `Boolean`
a|Check conformance of `_a_desc_type_` to `_an_anc_type_`; the types may be generic, and may contain open generic parameters like 'T' etc. These are replaced with their appropriate constrainer types, or Any during the conformance testing process.

Conformance is found if:

* [base class test] types are non-generic, and either type names are identical, or else `_a_desc_type_` has `_an_anc_type_` in its ancestors;
* both types are generic and pass base class test; number of generic params matches, and each generic parameter type, after 'open parameter' substitution, recursively passes; `_type_name_conforms_to_` test
* descendant type is generic and ancestor type is not, and they pass base classes test.

h|
|*any_class_definition* (): `BMM_CLASS`
a|`BMM_CLASS` instance for the `Any` class. This may be defined in the BMM schema, but if not, a default `Any` class will be generated.
|===
