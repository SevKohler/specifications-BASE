= Core Package

== Overview

The `core` package, shown below, defines the main BMM model.

[.text-center]
.base.bmm.core Package
image::{uml_export_dir}/diagrams/BASE-bmm.core.svg[id=core_package, align="center"]

== Structure

A BMM model is structured in the same basic way as a UML model, i.e. with a hierarchical package containment structure and a set of class definitions. Class definitions consist of property definitions, each of which refers to a type, which in turn refers to a 'base class'. The general structure is shown below. Structures specific to generic and container types are shown in relevant sections below.

[.text-center]
.BMM model structure
image::diagrams/bmm_structure.svg[id=bmm_structure, align="center"]

As can be seen here, ignoring packages, a BMM model consists of class definitions containing property definitions, each of a particular type, represented as an instance of a descendant of `BMM_TYPE`.

== Documentation

A `_documentation_` attribute is inherited from `BMM_MODEL_ELEMENT` into `BMM_CLASS`, `BMM_PROPERTY`, `BMM_MODEL` and `BMM_PACKAGE` (the latter two via `BMM_PACKAGE_CONTAINER`).

[.tbd]
TBD: expand to be of type `Hash<String,Any>` or similar?

== Semantics

=== The Class / Type Division

One of the foundational concepts in the BMM is a distinction between _class_ and _type_, in common with the type systems of the modern forms of most object-oriented languages. Classes are _definitional_ entities, while 'type' has two meanings: as the static (design time) type of a class feature (property or function result), and as the dynamic (run-time) type of the object referred to by or computed by that feature. In a static model, types are references. For simple types, they refer to the corresponding simple class definition, but for generic types, they refer to a particular usage of a generic class definition. A given generic class may generate numerous types.

This central division in the BMM is reflected in the two types `BMM_CLASS` and `BMM_TYPE`. The common parent class `BMM_ENTITY` defines a small number of properties that classify both classes and types in a model: `_entity_metatype_`, `_is_abstract_` and `_is_primitive_`. These are combined to produce a String classifier `_entity_category_`, which can be used to help visualise elements of a BMM model.

The Boolean attribute `_is_abstract_` on an entity indicates an abstract class in a BMM model, or a type based on an abstract class. The attribute `_is_primitive_` indicates that a class in a BMM model is considered to be part of a primitive type set (typically corresponding to primitive types in another type system); for types, it is derived from the setting of the `_base_class_`. Primitive status has no effect on BMM model semantics, and is provided as a convenience for visualisation and type-system mapping.

The taxonomy represented by `BMM_ENTITY._entity_category_` is illustrated below.

[.text-center]
.BMM entity taxonomy
image::diagrams/bmm_entity_taxonomy.svg[id=bmm_entity_taxonomy, align="center"]

=== Types

Types are used for two purposes in a BMM model:

* to define the _type of a property_;
* to define type(s) of _inheritance ancestors of class definitions_.

Every type entity can be mapped back to its generating class(es), which provide the definitional basis for the type. The BMM class `BMM_TYPE` and its descendants define the kinds of types available in a BMM model. The `BMM_TYPE` class features common to all meta-types:

* _base_class_: a reference to the generating class;
* _type_name_: the effective type name of an entity; for simple classes, this will just be the class name (`BMM_CLASS._name_`); for generic and container classes it will be generic name such as `List<T>`, `Interval<T>` etc; for feature types it will be the declared type, i.e. a simple name, an open type name (e.g. `T`) or a generic type name (e.g. `Interval<Time>`);
* _type_signature_: a form of the type name that can be used as a fully-defined type signature, which for generic classes includes generic constrainer types, giving a signature such as `Interval<T:Ordered>`.

The type of a property in a BMM model has one of the following `BMM_TYPE` descendants as its metatype:

* a `BMM_SIMPLE_TYPE` - corresponds to a simple type such as `Document`;
* a `BMM_GENERIC_TYPE` - a type generated by the use of a generic class with one or more filled type parameters, e.g. `Interval<Time>`, `Packet<T,Payload>`;
* a `BMM_CONTAINER_TYPE` - a type generated by the use of a linear container type such as `List<T>`, `Hash<T,U>` with actual generic parameters;
* a `BMM_PARAMETER_TYPE` - corresponds to a generic parameter type from the class type definition, e.g. `T`, `U` etc.

==== Primitive Types

As noted above, class definitions can be marked as being 'primitive' within a BMM model, enabling them to be visualised and queried as a separate group without otherwise impacting on the semantics of the entity in BMM meta-type system. The following shows part of a BMM model in which a number of classes are classified as primitive (shown in light and dark grey).

[.text-center]
.Generic type - closed simple
image::images/awb_primitive_types.png[id=awb_primitive_types, align="center", width="50%"]

==== Generic Types

A generic type is any type based on a generic class, which has one or more open type parameters that are substituted for actual types in its declaration. For example, the generic type `Interval<Quantity>` can be used in a model that contains the generic class `Interval<T:Ordered>` and `Quantity`. A typical programmatic usage of such a type, and its instantiated BMM model structure are shown below.

[.text-center]
.Generic type - closed simple
image::diagrams/bmm_structure-generic_1.svg[id=bmm_structure_generic_1, align="center"]

The generic parameters of a generic type may be:

* a substitution of a formal parameter from the generic class with a concrete type, including other generic types and container types;
* an unsubstituted formal parameter. 

Consequently, a generic type may be:

* _fully closed_: all formal parameters substituted e.g. `Interval<Quantity>`;
* _partially closed_: at least one formal parameter is substituted e.g. `Document<ClinicalContent, U>`;
* _fully open_: no formal parameters substituted, e.g. `Document<T, U>`.

The feature `_is_partially_closed ()_` defined on `BMM_GENERIC_TYPE` can be used to distinguish the latter two cases. 

The following diagram shows the BMM instance structure created for a generic type based on a generic class and another generic type.

[.text-center]
.Generic type - closed container
image::diagrams/bmm_structure-generic_2.svg[id=bmm_structure_generic_2, align="center"]

The following shows the BMM instance structure of a generic type that is fully open.

[.text-center]
.Generic type - open
image::diagrams/bmm_structure-generic_3.svg[id=bmm_structure_generic_3, align="center"]

==== Container Types

In object-oriented type theory, 'container' types are generic types whose outer class happens to have the semantics of a container object, such as a list, set etc. In the BMM, containers and non-container generic types are distinguished via the classes `BMM_GENERIC_TYPE` and `BMM_CONTAINER_TYPE`. This allows the BMM to treat container types in a special way. A `BMM_CONTAINER_TYPE` can be thought of as a 1:N counterpart to a `BMM_SIMPLE_TYPE`, such as the type `List<Paragraph>` compared to `Paragraph`. `BMM_GENERIC_TYPE` is typically used for objects considered to be singular, but whose types are a product of the base class and one or more parameter types, e.g. `Interval<Quantity>`. 

The explicit provision of `BMM_CONTAINER_TYPE` enables BMM models to mention logical linear container types such as `Array<T>`, `List<T>` and `Set<T>`, on the assumption of their standard semantics in computer science , without worrying about providing concrete types which may be numerous and also variable across programming languages, e.g. `ArrayedList<T>`, `LinkedSet<T>`, `ArrayedStack<T>` and so on. (This corrects one of the errors in UML, which does not represent containment via typing, but via cardinality, and uniqueness constraints.)

The following diagram shows how the container type `List<Paragraph>` is represented in a BMM model.

[.text-center]
.Container Type
image::diagrams/bmm_structure-container.svg[id=bmm_structure_container, align="center"]

=== Classes and Properties

Class definitions are the core of any BMM model. BMM distinguishes between simple, enumeration and generic class definitions via the BMM classes `BMM_CLASS`, `BMM_ENUMERATION` and `BMM_GENERIC_CLASS`. The enumeration meta-type adds a set of enumeration labels and option `String` or `Integer` values, in the manner of contemporary languages such as Java and C#, while the generic class meta-type adds he semantics of formal generic parameters.

Class properties are defined using the generic class `BMM_PROPERTY <T: BMM_TYPE>`. The use of a generic meta-type provides a direct way of expressing the semantics of property meta-types as listed above. 

In modelling or programming terms, the properties of a class constitute the features it _introduces with respect to its inheritance parent(s)_. We can think of this list of properties as the _differential_ set. A 'top-level' class with no declared inheritance ancestor is considered to inherit by default from the `Any` class, and its property set is relationally differential.

In contrast, the _effective_ set of properties for a class is the result of evaluating these lists of properties down the inheritance hierarchy to obtain the _flat_ set of properties. The features _properties_ and _flat_properties_ defined on `BMM_CLASS` provide access to these two lists for any class.

==== Enumeration Classes

xxx

==== Generic Classes

xxx

=== Inheritance

The BMM supports single and multiple inheritance, although it does not distinguish between different types of inheritance relation as some programming languages do. The evaluation of inheritance relations defined in a BMM schema results in an acyclic graph such that ancestors and descendants can be visualised for any class. The following screen shot shows the ancestors view of a class `OBSERVATION`.

[.text-center]
.BMM class - ancestors view
image::images/awb_class_ancestors.png[id=awb_class_ancestors, align="center", width="40%"]

The next screenshot shows the descendants view of one of the ancestorsclasses of the same class.

[.text-center]
.BMM class - descendants view
image::images/awb_class_descendants.png[id=awb_class_descendants, align="center", width="40%"]

Multiple inheritance is typically used in the definition of classes that have a Liskov substitution inheritance relation as well as an implementation inheritance relation. The following shows a class `DV_INTERVAL<T>` multiply inheriting from `Interval<T>` and `DATA_VALUE`.

[.text-center]
.BMM class - descendants view
image::images/awb_multiple_inheritance.png[id=awb_class_inheritance, align="center", width="50%"]

==== Generic Effective Classes

xxxxx

[.text-center]
.BMM class - ancestors view with generic effective class
image::images/awb_class_ancestors-generic_effective.png[id=awb_class_ancestors_generic_effective, align="center", width="50%"]


== Model Relations

=== Class Suppliers

xxx

=== Class Ancestors

xxx

=== Class Descendants

xxx

== Class Definitions

include::{uml_export_dir}/classes/bmm_definitions.adoc[]
include::{uml_export_dir}/classes/bmm_model_element.adoc[]
include::{uml_export_dir}/classes/bmm_model_core.adoc[]
include::{uml_export_dir}/classes/bmm_model.adoc[]
include::{uml_export_dir}/classes/bmm_package_container.adoc[]
include::{uml_export_dir}/classes/bmm_package.adoc[]

include::{uml_export_dir}/classes/bmm_entity.adoc[]
include::{uml_export_dir}/classes/bmm_class.adoc[]
include::{uml_export_dir}/classes/bmm_property.adoc[]
include::{uml_export_dir}/classes/bmm_container_property.adoc[]

include::{uml_export_dir}/classes/bmm_type.adoc[]
include::{uml_export_dir}/classes/bmm_base_type.adoc[]
include::{uml_export_dir}/classes/bmm_simple_type.adoc[]
include::{uml_export_dir}/classes/bmm_container_type.adoc[]
include::{uml_export_dir}/classes/bmm_generic_type.adoc[]
include::{uml_export_dir}/classes/bmm_parameter_type.adoc[]
include::{uml_export_dir}/classes/bmm_generic_class.adoc[]
include::{uml_export_dir}/classes/bmm_generic_class_effective.adoc[]
include::{uml_export_dir}/classes/bmm_enumeration.adoc[]
include::{uml_export_dir}/classes/bmm_enumeration_string.adoc[]
include::{uml_export_dir}/classes/bmm_enumeration_integer.adoc[]

