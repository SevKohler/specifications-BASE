= BMM Syntax

== Overview

== Header Items

[source, odin]
--------
------------------------------------------------------
-- BMM version on which these schemas are based.
------------------------------------------------------
bmm_version = <"2.1">


------------------------------------------------------
-- schema identification
-- (schema_id computed as <rm_publisher>_<schema_name>_<rm_release>)
------------------------------------------------------
rm_publisher = <"openehr">
schema_name = <"adltest">
rm_release = <"1.0.2">

------------------------------------------------------
-- schema documentation
------------------------------------------------------
schema_revision = <"1.0.36">
schema_lifecycle_state = <"stable">
schema_description = <"openEHR schema to support test archetypes">

--------

== Inclusions

[source, odin]
--------
------------------------------------------------------
-- inclusions
------------------------------------------------------
includes = <
	["1"] = <
		id = <"openehr_basic_types_1.0.2">
	>
>

--------

== Archetyping related

Three archetyping related attributes can be set below, but would not usually all in the same schema. Only the archetype_rm_closure_packages variable is needed in at least one schema, usually the top-most one. 

`archetype_parent_class` defines a base class from the Reference Model that provides archetyping capability in RM data structures. It is optional, and there need be no such class in the RM. In the openEHR and 13606 RMs, this class exists, (`LOCATABLE`, and `RECORD_COMPONENT` respectively). Defining it here has the effect in tools that the class tree under which archetypes are arranged contains only RM classes inheriting from this class, e.g. LOCATABLE classes in the case of openEHR. If nothing is set here, all classes in the RM are assumed as candidates for archetypes. This attribute, if defined, must be defined in the same schema that defines the referenced class.                                                                     

`archetype_data_value_parent_class` defines a base class from the Reference Model whose descendants are considered to be 'logical data types' (i.e. of some higher level than the built-in primitive types String, Integer etc). This attribute is optional, even if the RM does have such a class, and is only used to help tooling provide more intelligent display, e.g. in statistical reports.                        

This attribute, if defined, must be defined in the same schema that defines the referenced class.

If `archetype_parent_class` is not set, designate a class whose descendants should be made visible in tree and grid renderings of the archetype definition. For openEHR and CEN this class is normally the same as the archetype_parent_class, i.e. `LOCATABLE` and `RECORD_COMPONENT` respectively. It is typically set for CEN, because `archetype_parent_class` may not be stated, due to demographic types not inheriting from it. The effect of this attribute in visualisation is to generate the most natural tree or grid-based view of an archetype definition, from the semantic viewpoint.

`archetype_rm_closure_packages` defines the package or packages that are considered the archetyping namespace used in archetype multi-axial ids. For example, in openEHR, an archetype is identified by an id of the form `openEHR-EHR-OBSERVATION.some_obs.vN`. The 'EHR' in the above is an 'RM package closure', i.e. the name of an RM package whose class closure by reachability provides the set of classes that may be archetyped in the 'EHR' namespace. The reason for this is somewhat subtle: consider that if you want archetypes based on classes defined directly within a package P, and you also define these archetypes that re-use other archetypes based on more basic types like openEHR's `CLUSTER` or similar (typically not defined in the head package), then you will inevitably have archetypes based on `CLUSTER` only for use with EHR archetypes e.g. archetypes based on `OBSERVATION`. However, you may well create archetypes based on `CLUSTER` only for use with e.g. top-level archetypes from the demographic package. The archetype_rm_closure_packages setting is used to define the root id namespaces for archetypes, allowing low-level archetypes to be designated for use with one or other high-level archetype. E.g. `openEHR-EHR-CLUSTER.bp_position.v1` would be used only with `openEHR-EHR-OBSERVATION.bp_measurement.vX`, or similar, and most likely not with any `openEHR-DEMOGRAPHIC-XXXX.yyyy.vN` archetype. Note that in openEHR, there is nothing to prevent such cross-namespace reuse - it is just a design guideline. This attribute, must be defined in the same schema that defines the referenced package(s).

[source, odin]
--------
------------------------------------------------------
-- archetyping
-- override archetype parent class from included schema
------------------------------------------------------
archetype_parent_class = <"CLASS_NAME">
archetype_data_value_parent_class = <"CLASS_NAME">
archetype_visualise_descendants_of = <"CLASS_NAME">
archetype_rm_closure_packages = <"org.openehr.test_pkg", ...>
--------


== Package Definition

The packages definition should be self-explanatory: just name the classes and packages in a recursive fashion.

NOTE: only top-level package ids can be paths (i.e. contain the '.' character)

NOTE: only classes defined in the same schema can be referenced in the package section in that schema.

NOTE: make sure that the ODIN 'keys' are the same as the 'name' attributes in each block.

[source, odin]
--------
------------------------------------------------------
-- packages
------------------------------------------------------
packages = <
	["org.openehr.test_pkg"] = <
		name = <"org.openehr.test_pkg">
		classes = <"WHOLE", "SOME_TYPE", "BOOK", "CHAPTER", "ENTRY", "CAR", "CAR_BODY">
	>
>
--------

== Primitive Types

Definitions for primitive types in a BMM schema are just normal class definitions within a `primitive_types` block. Types that are included here are usually types corresonding to primitives in target programming languages, XML schema or other downstream technologies. These types can be be detected as primitive types by tools, but otherwise are processed in the same way as types defined in the main `class_definitions` group.

NOTE: unlike UML, all container types such as `List<T>`, `Hash<V,K>` etc are exlicit in a BMM schema, and consequently, such types are normally defined (including with generic parameters) in a BMM schema.

[source, odin]
--------
------------------------------------------------------
-- primitive types
------------------------------------------------------

primitive_types = <
	["Any"] = <
		name = <"Any">
		is_abstract = <True>
	>
	["Ordered"] = <
		name = <"Ordered">
		is_abstract = <True>
		ancestors = <"Any", ...>
	>
>
--------

== Class Definitions

The main group of class definitions in a schema occurs within the `class_defintions` block. Each definition is a keyed ODIN object block correspnding to a serialised `P_BMM_CLASS` object, where the key is the class name. Since `name` is also BMM meta-model attribute, the class

The subsections below exlain the various features of a class definition.

[source, odin]
--------
------------------------------------------------------
-- classes
------------------------------------------------------

class_definitions = <
	["ITEM"] = <
		name = <"ITEM">
		ancestors = <"Any", ...>
		is_abstract = <True>
	>

    -- etc
    
>
--------

=== Basic Class properties

=== Optionality

=== Container Properties

=== Generic Classes

=== Generic Properties

=== Enumerated Classes

