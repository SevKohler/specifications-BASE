= The Expression Language

== Overview

This section describes the openEHR Expression Language (EL). In the various contexts where EL expressions are used, the syntax provides a foundation for concrete  syntaxes supporting specific value-referencing mechanisms, as well as other types of rules, operands etc. The language consists of two types of construct: functional and procedural. The former includes all value-returning entities, including literals, constants, variable references, function invocations, and expressions constructed from them using operators, parentheses etc. The procedural elements include assignments, control structures and procedure invocations.

Formally, an expression is any of the following value-returning entities:

* _terminal entities_:
** _literals_;
** _constants_;
** _symbolic variables_;
** _function calls_;
* _predicates_:
** _check() predicate_: special expression for asserting a truth value;
** _defined() predicate_: special expression for determing validity of external variable;
* _complex expressions_:
** _equality operator_: equality operator;
** _primitive operators_: arithmetic operators, relational operators, boolean operators;
** _collection operators_: logical quantification operators.

EL is designed syntactically as a readable language while being underpinned by fully class-based functional semantics, which are supplied either by a minimal built-in core, and mostly by bindings to external computing context. In this way, syntax elements such as the '+' operator for the `Date` type, or the `for_all` universal quantifier operator may be mapped to underlying methods such as `Date._add_()` and `Container._for_all_()`.

EL is not intended for writing functions or classes, rather it is designed as a minimalist logic-based language in which expressions can be written, but whose programming is undertaken inside libraries in existing programming languages. Routine declarations in EL are the primary mechanism to connect external software libraries to the EL context. In EL, both functions and procedures are supported, and are collectively known as _routines_.

== Syntax style

The syntax style used here is of the Pascal variety, i.e. words rather than programming symbols such as braces (`{}`). The intention is to provide a syntax that is more easily readable to non-IT professionals as well as IT professionals, since it is likely that healthcare professionals will be among the principle authors of EL texts. This choice leads to EL syntax such as the following.

----
    -- a universal quantifier expression
    if for_all v in $systolic_bp_samples : v <= Systolic_bp_threshold then
        -- statements
    end
    
    -- a when/then block
    when $systolic_bp
        matches |>= 200.0| then
            -- statements to raise emergency alert

        matches |>= 180.0| then
            -- statements to request nurse check

        ...
    end    
----

In the above, nearly all lexical elements are words, such as `if`, `in`, `when`, `then` and so on, leading to a more natural reading experience.

Nevertheless, the style chosen here should not be regarded as fixed forever, and indeed it is a relatively simple matter to create alternative 'syntax skins', such as one for developers used to C language syntax descendants such as Java, TypeScript and so on.

The lexical style used is so-called 'snake_case' rather than so-called 'CamelCase', in common with other openEHR specifications, but either may be used in real applications. One reason for using snake-case may be to render EL texts more readable to the non-IT professional.

== Types

The Expression language is fully typed, and _assumes_ the same set of {openehr_foundation_types}[Foundation Types] as other openEHR components, namely:

* primitive types;
* container types:
** `List<T>`, i.e. an ordered list of elements of primitive type T;
** `Set<T>`, i.e. a set of elements of primitive type T;
** `Hash<K:Ordered,V>`, i.e. a Hash table or dictionary;
* an interval type:
** `Interval<T: Ordered>` where T is any ordered primitive type, i.e. `Integer`, `Real`, and any of the Date/time types.

These types are described below.

=== Primitive Types

The primitive types are shown below.

[cols="1,3",options="header"]
|=================================================================
|Name                   |Description

| `Boolean`             |Boolean value
| `Integer`             |Integer value
| `Real`                |Real value
| `Date`                |ISO8601-format date
| `Date_time`           |ISO8601-format date/time
| `Time`                |ISO8601-format time
| `Duration`            |ISO8601-format duration
| `String`              |String
| `Uri`                 |Uri in <<uri_syntax,RFC3986 format>>
| `Terminology_code`    |Terminology code reference
|=================================================================

Automatic type promotion from `Integer` to `Real` applies to all integer and real values and expressions, in the same fashion as most programming languages.

[.tbd]
TBD: do we need `Integer64` and `Real64`?

=== Container Types

The same container types as defined in the {openehr_foundation_types}#_structure_types[BASE Foundation Types specification] are supported in EL, as follows.

[cols="1,3",options="header"]
|=================================================================
|Name                   |Description

| `Container<T>`        |Abstract parent of `List`, `Set` and `Hash` types
| `List<T>`             |Linear list of items of any primitive type, allowing order and repeated membership
| `Set<T>`              |Set of items of any primitive type; no order, unique membership
| `Hash<K:Ordered, V>`  |Indexed linear container
|=================================================================


[.tbd]
TBD: the following is functional style; we would need keywords to enable it in the EL syntax, e.g. `has` etc. Also, `has()` can be done via `there_exists()`.

The above types each have an assumed interface consisting of functions and procedures that apply to all members of the container, consistent with the semantics of the container. These include the following.

----
    has (v: T): Boolean
            -- True if container contains v
----

Any such method may be accessed in the usual way, using dot notation, i.e. as shown below for the method `_has()_`.

----
    $heart_rate_samples: List<Real>
    High_threshold: Real = 200.0
    
    if $heart_rate_samples.has (High_threshold) then
        -- statements
    end
----

=== Interval Type

The same `Interval` type as defined in the {openehr_foundation_types}#_interval[BASE Foundation Types specification] is supported in EL, as follows.

[cols="1,2",options="header"]
|=================================================================
|Name                   |Description

| `Interval<T>`         |Interval of any ordered primitive
|=================================================================

Automatic type promotion from `Interval<Integer>` to `Interval<Real>` applies to all integer and real values and expressions, in the same fashion as most programming languages.

[.tbd]
TBD: the following is functional style; we would need keywords to enable it in the EL syntax, e.g. `contains`, `overlaps` etc.

Various methods are defined for `Interval<T>`, as follows.

----
    has (v: T): Boolean
            -- True if for Interval contains v

    overlaps (other: like Current): Boolean
            -- True if this Interval overlaps other
            
    contains (other: like Current): Boolean
            -- True if this Interval contains other
----

== Declarations

Symbolic references are declared in the form `name: Type`. Multiple variables may be declared on the same line. The following shows various declarations:

--------
    date_of_birth: Date
    age_in_years: Integer
    
    weight, height, bmi: Real
    
    heart_rate_samples: List<Real>
--------

== Terminal Entities

This section describes the various kinds of terminal entities that may appear in EL expressions.

=== Literals

Literal values are expressed in the {openehr_odin}#_primitive_types[ODIN syntax], with the exception of `List<T>` and `Set<T>` which are distinguished in EL with specific types of brackets.

[cols="1,2,3",options="header"]
|=================================================================
|Type                   |Literal value                          |Notes

| `Boolean`             |`True`, `False`                        |
| `Integer`             |`10`, `-4`, `1024`                     |
| `Real`                |`10.0`, `0.345`                        |
| `Date`                |`2004-08-12`                           |ISO8601-format date
| `Date_time`           |`2004-08-12T12:00:59+0100`             |ISO8601-format date/time
| `Time`                |`12:00:59`                             |ISO8601-format time
| `Duration`            |`P39W`                                 |ISO8601-format duration
| `String`              |`"this is a string"`                   |
|                       |`[blood_pressure]`                     |Extract the string value for the symbol `blood_pressure` from the EL terminology
| `Uri`                 |`https://en.wikipedia.org/wiki/Everest`|Uri in <<uri_syntax,RFC3986 format>>
| `Terminology_code`    |`[snomed_ct::389086002]` +
                         `[snomed_ct::389086002\|Hypoxia\|]`    |Terminology code in openEHR format


| `List<T>`             |`[val, val, ...]`                      |
| `Set<T>`              |`{val, val, ...}`                      |
| `Hash<K:Ordered, V>`  |`< +
                              ["key1"] = <val1> +
                              ["key2"] = <val2> +
                              ... +
                              ["keyN"] = <valN> +
                         >`                                     |A table of values of any type V, +
                                                                 keyed by values of any `Ordered` descendant K, +
                                                                 typically `String` or `Integer`

| `Interval<T>`         |                                       |
|                       |`\|N..M\|`                             |the two-sided interval N >= x \<= M
|                       |`\|>N..M\|`                            |the two-sided interval N > x \<= M
|                       |`\|N..<M\|`                            |the two-sided interval N >= x < M
|                       |`\|<N\|`                               |the one-sided interval x < N
|                       |`\|>N\|`                               |the one-sided interval x > N
|                       |`\|\<=N\|`                             |the one-sided interval x \<= N
|                       |`\|>=N\|`                              |the one-sided interval x >= N
|                       |`\|N +/-M\|`                           |the two-sided interval of N ±M
|                       |`\|N±M\|`                              |the two-sided interval of N ±M
|=================================================================

=== Constants

Constants are defined via the use of the equality operator `=` in a type declaration, as follows.

--------
    Mph_to_kmh_factor: Real = 1.6
    Pounds_to_kg: Real = 0.4536
--------

The result of the declaration is to defined the symbols `Mph_to_kmh_factor` and `Pounds_to_kg` as immutable constants.

=== Variables

Two types of variable are recognised in EL: internal and external. These are distinguished respectively by the naming style `name` and `$name`. An external variable is one that is mapped to an external entity, declared in the data context for the EL expression.

Examples of declarations of both kinds are as follows.

--------
    $date_of_birth: Date                -- an external variable
    age_in_years: Integer               -- an interval variable
    
    $weight, $height, bmi: Real         -- two external variables and an internal variable
    
    $heart_rate_samples: List<Real>     -- an external variable bound to a List of Real values
--------

Every external variable must have a counterpart in the EL data context to be valid.

=== Functions

In EL, the function is the primary means to link expressions to implementations. Both functions and procedures are supported, and are collectively known as _routines_. However, from a semantic point of view, only functions, or more correctly function invocations, qualify as expression elements. Procedures do not have associated values, and are described in the section on procedural elements below.

In EL, a function is a routine that returns a result and is assumed to have no side-effects on previously declared entities. It has a signature of the form:

----
    -- NB: not EL text
    <T_arg1, T_arg2, ....>: T_result
----

Typical examples of function signatures:

----
    -- NB: not EL text
    : Date                          -- signature of a 0-order function like current_date()
    <Real, Real>: Real              -- signature of a 2nd-order function like '*' for the domain R
    <Integer, Integer>: Integer     -- signature of a 2nd-order function like 'add' for the domain I
----

EL does not provide a way to programmatically define routines (i.e. it does not try to be a programming language), instead, it provides a way of _declaring routine signatures_, using the `func` keyword. This is similar to the declaration of methods in interface classes in languages like C# and Java.

Examples of function declarations:

----
    func current_date(): Date                            -- a function that obtains today's date
    
    func bmi_metric (height, weight:Real): Real          -- a function that computes BMI from metric inputs
    
    func sum (vals: List<Real>): Real                    -- a function that computes the sum of a list of Reals
----

The following example shows a function declaration for a function `_tnm_major_number_()` that extracts various elements of {wikipedia}/TNM_staging_system[Tumour/Node/Metastasis ('TNM')] cancer staging values, such as `'Tis'`, `'G3'` and so on, and uses them in a Boolean expression whose value is assigned to the variable `is_luminal_A`.

----
    func tnm_major_number (tnm_val: String): Integer

    is_luminal_A: Boolean := tnm_major_number (tnm_t) < 3 and tnm_major_number (tnm_n) < 2 and tnm_major_number (tnm_g) < 3
----

Functions are mapped to class methods in external libraries in the <<_computing_context, Computing Context>> section of an EL text.

==== Built-in Functions

Some basic functions are assumed to be provided in an EL environment, in order to enable EL expressions to be more standardised. These can be provided by the implementation using the above methods of declaration and external binding.

The built-in functions are listed below.

----
    current_date(): Date                   -- obtain today's date
    current_time(): Time                   -- obtain the current clock time
    current_date_time(): Date_time         -- obtain the current date and time
    
    sum (Container<T: Numeric>): T         -- compute the sum of members in a container
    min (Container<T: Numeric>): T         -- compute the minimum value in a container
    max (Container<T: Numeric>): T         -- compute the maximum value in a container
    avg (Container<T: Numeric>): T         -- compute the average value in a container

    count (Container<T>): Integer          -- compute the number of items in a container
----

These functions operate as a shorthand for underlying object-oriented calls defined on various kinds of objects, and would be implemented by such mappings. For example, `_current_date_()` might be mapped to a `_now_()` function on the type `Date`. The statistical functions `_sum_()` etc might be mapped to functions of similar names on types such as `Container_numeric`, derived from `Container<T: Numeric>`.

== Predicates

=== check() Predicate

In various circumstances, exceptions may be generated by EL expression evaluation. This primarily occurs when the value of a bound variable is undefined. EL provides a way of controlling execution when exceptions may occur, using a `check` expression, as follows.

----
    check ($heart_rate > 0.0)
----

The meaning of this statement is that if the condition evaluates to `False`, a `check violation` is generated, which may be handled by an exception handler.

The `check` instruction can be used in a conditional block to ensure certain conditions hold on entry to the block, as follows:

----
    if check ($heart_rate > 0.0) then
        -- statements mentioning $heart_rate
    end
----

[.tbd]
TBD describe exception handling.

=== defined() Predicate

Variables that are bound to entities in the data context function differently from local variables, since their availability is predicated on the existence of the relevant entities. For example, the variable `$body_weight` may be bound to a call that retrieves a patient weight from the EHR, via an appropriate API call. There is no guarantee that the value is available, so `$body_weight` may therefore be undefined in a sense not applicable to local variables. In a programming language, if a variable is not explicitly set, it has either the default value of the type (e.g. `0` for `Integer`) or a random value of the correct type. This behaviour is appropriate for local variables, but for bound variables that cannot be evaluated because the external entity does not exist, an explicit mechanism is needed to test for validity.

The approach used for EL is to allow bound variables to be used freely, as for local variables, but if a bound variable cannot be evaluated from the data context, an `'undefined value'` exception is generated, indicating which variable could not be evaluated. To impose more control, the predicate `defined ()` can be used within a `check` statement to ensure that one or more variables can be populated before proceeding with logic that depends on them, as follows:

----
    if defined ($heart_rate) and defined ($blood_pressure) then
        -- statements mentioning $heart_rate and $blood_pressure
    end

    if check (defined ($heart_rate) and defined ($blood_pressure)) then  -- generates exception if False
        -- statements mentioning $heart_rate and $blood_pressure
    end
----

Another difference between bound and local variables is when they are evaluated. In the execution of a larger EL text containing multiple mentions of a bound variable `$v`, is `$v` read from the data context only once, at the first mention, or is it evaluated new each time, or on some other basis? The approach used in EL is to allow the evaluation basis to be stated in the context binding section of an EL text using the `_currency_` property.

To assert that a certain part of a larger data structure exists depending on values elsewhere (usually in the same structure, but not necessarily), the following construct can be used:

--------
    check ($is_smoker implies defined ($smoking_details))
--------

== Complex Expressions

Complex expressions in EL consist of non-atomic value-returning expressions, in a familiar typed, operator-based syntax common to many programming languages and logics. In EL, the syntactic use of operators is understood as a shorthand for certain functions assumed to be available on certain types, and an EL implementation would map such operators to the appropriate methods in a class library.

=== Equality Operator

The equality operator `=` is special in EL as in most languages, and has two meanings. For all primitive types, the semantics are value comparison, while for container and other non-primitive types, the semantics are reference comparison.

=== Primitive Operators

Primitive operators in EL are the infix or prefix syntax form of various functions available on primitive types. For example, the operator `-` (minus) is defined on the class `Numeric` (an inheritance ancestor of the classes `Integer`, `Real` etc) as the following (using syntax from Java, TypeScript and similar languages):

----
    function minus<T extends Numeric> (other: T): T
----

This means that where the expressions `100 - 5` or `int_val_1 - int_val_2` are encountered in EL, what is really invoked is `Integer._minus_()`.

The operators for Numeric and Boolean types supported in EL are shown below.

[cols="1,1,1,3",options="header"]
|=================================================================
|Identifier   |Textual +
               Rendering 	  |Symbolic +
                               Rendering  |Meaning
                               
4+^h|Arithmetic Operators - Numeric operands and result; descending precendence order

|exp          | ^             |≥          |Expontentiation
|times        | *             |*          |Multiplication
|divide       | /             |/          |Division
|mod          | %             |%          |Modulo (whole number) division
|plus         | +             |+          |Addition
|minus        | -             |-          |Subtraction

4+^h|Relational Operators - Numeric, Date/time operands and Boolean result; equal precedence

|eq           | =             |=          |Value equality
|ne           | !=            |≠          |Inequality relation
|lt           | <             |<          |Less than relation
|le           | \<=           |≤          |Less than or equal relation
|gt           | >             |>          |Greater than relation
|ge           | >=            |≥          |Greater than or equal relation

4+^h|Logical Operators - Boolean operands and result; descending precendence order

|not          |not, ~ 		|∼  		 |Negation, "not p"
|and          |and 			|∧ 			|Logical conjunction, "p and q"
|or           |or 			|∨ 			|Logical disjunction, "p or q"
|xor          |xor 			|⊻ 			 |Exclusive or, "only one of p or q"
|implies      |implies 		|⇒ 			 |Material implication, "p implies q", or "if p then q"

|=================================================================

In addition, some operators are defined on the other primitive types, corresponding to underlying functions defined on the relevant types. These are as follows:

[cols="1,2,4",options="header"]
|=================================================================
|Operator       |Typical +
                 method    	                                    |Meaning
                               
3+^h|String Operators

|`+`             |`append(other: String)`                       |String concatenation, appending

3+^h|Date/time arithmetic operators

|`+`             |`Date.add(d: Duration): Date`                 |Add a duration to a date
|`+`             |`Time.add(d: Duration): Time`                 |Add a duration to a time
|`+`             |`Date_time.add(d: Duration): Date_time`       |Add a duration to a date/time
|`+`             |`Duration.add(d: Duration): Duration`         |Add a duration to a duration

|`-`             |`Date.subtract(d: Duration): Date`            |Subtract a duration from a date
|`-`             |`Time.subtract(d: Duration): Time`            |Subtract a duration from a time
|`-`             |`Date_time.subtract(d: Duration): Date_time`  |Subtract a duration from a date/time
|`-`             |`Duration.subtract(d: Duration): Duration`    |Subtract a duration from a duration

|`-`             |`Date.diff(d: Date): Duration`                |Difference of two dates
|`-`             |`Time.diff(d: Time): Duration`                |Difference of two times
|`-`             |`Date_time.diff(d: Date_time): Duration`      |Difference of two date/times

3+^h|Duration arithmetic operators

|`+`             |`Duration.add(d: Duration): Duration`         |Add a duration to a duration
|`-`             |`Duration.subtract(d: Duration): Duration`    |Subtract a duration from a duration

|=================================================================

Operator semantics that require further explanation are described below.

==== Logical Negation

All Boolean operators take Boolean operands and generate a Boolean result. The `not` operator can be applied as a prefix operator to all operators returning a Boolean result as well as a parenthesised Boolean expression.

==== Precedence and Parentheses

The precedence of operators follows the order shown in the operator tables above. To change precedence, parentheses can be used in the fashion typical of most programming languages, as shown below.

--------
    at_risk := $weight > 120 and ($is_smoker or $is_hypertensive)
--------

=== Collection Operators

A common need in an expression language featuring container types (i.e. sets, lists etc) is the need to perform basic reasoning over them. The two standard operators from predicate logic `there exists` (∃ operator) and `for all` (∀ operator) are defined in EL for the container types, and are kinds of Boolean-returning expressions.

The syntax of `there exists` is as follows:

----
    there_exists v in container_var : <Boolean expression mentioning v> 
----

Here, the `:` symbol is usually read in English as 'such that'. The expression may be used as in the following example:

----
    $systolic_bp_samples: List<Real>
    Systolic_bp_threshold: Real = 160.0
    
    if there_exists v in $systolic_bp_samples : v > Systolic_bp_threshold then
        -- statements
    end
----

The `for_all` operator has similar syntax:

----
    for_all v in container_var : <Boolean expression mentioning v>
----

Here, the `:` symbol is normally read as 'it holds that' A typical use is as follows:

----
    $systolic_bp_samples: List<Real>
    Systolic_bp_threshold: Real = 160.0
    
    if for_all v in $systolic_bp_samples : v <= Systolic_bp_threshold then
        -- statements
    end
----

The syntactic form of these two operators can be understood as a shorthand for the following underlying functions defined on the container types, available in most programming language libraries.

----
    there_exists (test(v: T): Boolean): Boolean
            -- True if there is any v in container for which test (v) is True

    for_all (test(v: T): Boolean): Boolean
            -- True if for every v in container, test (v) is True
----

== Procedural Elements

There are two kinds of procedural construct in EL: _statements_ and _control structures_. Neither is value-returning, in contrast to the functional elements of the language, rather they are state-changing. 

=== Assignment

An assignment is kind of statement used to assign the value of an expression to a writable variable using the `:=` operator. An assignment may be made in a declaration in the same way as in many programming languages. The right hand side of an assignment is any value-returning expression. Typical assignments are illustrated below.

--------
    speed_kmh: Real                             -- declaration
    speed_mph: Real := 35.0                     -- assignment in a declaration (not a constant)
        
    speed_kmh := speed_mph * Mph_to_kmh_factor  -- assignment
--------

The following shows an assignment with an expression using a function and an external variable.

----
    $date_of_birth: Date                   -- bound to data context
    age: Duration
    
    age := current_date() - $date_of_birth   
----

=== Procedure Invocation

EL supports the invocation of procedures in the same way as for functions. Computationally both are the same, being invocations of class methods or other functions defined in bound libraries. Semantically however, they are quite different. A procedure is a routine with a signature of the form:

----
    <T_arg1, T_arg2, ....>
----

I.e. a call taking 0 or more arguments, with no return type. Typical signatures include the following:

----
    <Real>                          -- a 1st-order procedure for the domain R
    <String, Integer>               -- signature of a procedure taking a String and an Integer argument
----

Procedures must be declared before use. This is done using the same syntax as for functions, as in the following example.

----
    proc alert_user (message: String; priority: Integer)    -- a procedure that generates a user alert
    
    if $systolic_blood_pressure > 180.0 then
        alert_user ([dangerous_blood_pressure], 1)          -- call the procedure
    end
----

=== Control Structures

Two control structures are provided in EL. They provide conditional logic structures from which statements (i.e. assignments and procedure calls) can be executed. Control structures may be nested in the usual way.

==== If / then

In common with most programming languages, EL provides a standard 'if / then / elseif / else' structure, as follows:

----
    if $systolic_blood_pressure > 160.0 then
        -- statements about high blood_pressure
    elseif $systolic_blood_pressure > 140.0 and $thyroid_t3 > 200 then
        -- statements about raised blood pressure and abnormal thyroid activity
    else
        -- other cases
    end
----

This structure is always evaluated in order.

==== When / then

EL provides a `when / matches / then` statement that is roughly equivalent to 'case' or 'switch' statements in most other languages. The `when` part indicates a  value-returning expression (such as a variable reference), which may be of any type, while the `matches` parts define value intervals that are used to match the `when` value. The first branch matched is executed.

the syntax is as follows.

--------
    when <expression>
        matches <value_interval_1> then
            -- statements
        matches <value_interval_2> then
            -- statements
            ...
        matches <value_interval_N> then
            -- statements
            
        else
            -- statements
    end
--------

The syntax for the match intervals is the standard EL Interval type literal syntax. An example 'when / then' statement is as follows:

--------
    when $systolic_bp
        matches |>= 200.0| then
            -- raise emergency alert

        matches |>= 180.0| then
            -- request nurse check

        matches |>= 160.0| then
            -- record 'high pressure'
    end
--------

= Material to remove?

== Routines as Objects

In EL, routine invocations are first-class entities, in a similar manner to functional programming languages. This enables two things:

*  a routine may be used as an argument in another routine call;
*  a routine invocation may be converted to other routine by the process known as _currying_.

An example of the first is shown below for the method `_some()_`, defined on the type `List<T>`.

----
    $heart_rate_samples: List<Real>
    Atrial_fibrillation_threshold: Real = 100.0
    
    if $heart_rate_samples.some (
        (v:Real): Boolean
            do
                Result := v > Atrial_fibrillation_threshold 
            end
        )
    then
        --
    end
----

== Iteration

Iteration in EL is performed over container and interval objects, i.e. variables or manifest constants. The general approach is to use built-in iterators of the container types, as follows.

----
    do_all (proc(v: T))
            -- execute proc(v) for every v in container

    do_if (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in container for which test(v) is True

    do_while (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in container until test (v) returns False

    do_until (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in container until test (v) returns True
----

Iteration over a range of integers can be performed using an `Interval<Integer>` literal, as follows:

----
    (|1..5|).do_all (
        (v: Integer)
            do
                -- statements
            end
    )
----

[.tbd]
TBD: more on how this works (it's defined on `Discrete_interval<T>`)
