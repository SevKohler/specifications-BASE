= EL Statements

== Overview

There are various kinds of non-expression statement in EL including _declarations_, _assignments_ and _control structures_. None is value-returning, in contrast to the expression elements of the language. In order to represent these elements, a structure of EL statements consisting of several sections is assumed. The main statements occur in a `definition` section, while two other optional sections are added, enabling constants and external variable declarations respectively to be made.

The logical structure of an EL structured text is thus as follows:

----
reference
    <declarations of constants>

data_context
    <declarations of external '$' variables>
    
definition
    <statements>
----

The following subsections describe these elements.

== Declarations

=== Constants

Constants are defined via the use of the equality operator `=` in type declarations in the `reference` section, as follows.

--------
reference
    Mph_to_kmh_factor: Real = 1.6
    Pounds_to_kg: Real = 0.4536
    Safe_glucose_limits: Interval<Real> = |0.0..6.5|
--------

The result of the declaration is to define the symbols `Mph_to_kmh_factor` and `Pounds_to_kg` as immutable constants.

Constants of complex types are declared using the ODIN syntax, for example, the following manifest value of type `DV_QUANTITY` from the {openehr_rm_data_types}[openEHR Data Types Model].

--------
reference
    Threshold_ogtt_glucose: DV_QUANTITY = <
        magnitude = <6.5>
        units = <"mmol/L">
    >
--------

[.tbd]
TBD: could also use archetype fragments here, as matching templates.

=== Variables

Symbolic variables are declared in two forms. The syntax `name: Type` is used for local variables, which are declared in the `definition` section.

External vraiables are declared in the `data_context` section, using the syntax `in|out|in_out name: Type`. The direction specifier indicates the intended use of the variable in the defnition, i.e. `in` = readable, `out` = writable, `in_out` = readable and writable.

In both cases, multiple variables may be declared on the same line. The following shows various declarations:

--------
data_context
    in $date_of_birth: Date
    in $weight, height: Real
    out $bmi: Real    
    in $bp_obs: OBSERVATION;

definition
    age_in_years: Integer    
    heart_rate_samples: List<Real>
--------

Every external variable must have a counterpart in the EL data context to be processable.

With explicit declarations added, the earlier `there_exists` examples is as follows:

----
reference
    Systolic_bp_threshold: Real = 160.0

data_context
    $systolic_bp_samples: List<Real>
    
definition
    if there_exists v in $systolic_bp_samples : v > Systolic_bp_threshold then
        -- statements
    end
----

=== Functions and Procedures

In EL, the functions and procedures are the primary means to make complex logic available to expressions. Both functions and procedures are supported, and are collectively known as _routines_.

In EL, a function is a routine that returns a result and is assumed to have no side-effects on previously declared entities. It has a signature of the form:

----
    -- NB: not EL syntax
    <T_arg1, T_arg2, ....>: T_result
----

Typical examples of function signatures:

----
    -- NB: not EL syntax
    : Date                          -- signature of a 0-order function like current_date()
    <Real, Real>: Real              -- signature of a 2nd-order function like '*' for the domain R
    <Integer, Integer>: Integer     -- signature of a 2nd-order function like 'add' for the domain I
----

EL does not provide a way to programmatically define routines (i.e. it does not try to be a programming language), instead, it provides a way of _declaring routine signatures_, using the `func` keyword. This is similar to the declaration of methods in interface classes in languages like C# and Java.

Examples of function declarations:

----
definition
    func current_date(): Date                        -- a function that obtains today's date
    func bmi_metric (a_height, a_weight:Real): Real  -- a function that computes BMI from metric inputs
    func sum (a_list: List<Real>): Real              -- a function that computes the sum of a list of Reals
----

The following example shows a function declaration for a function `_tnm_major_number_()` that extracts various elements of {wikipedia}/TNM_staging_system[Tumour/Node/Metastasis ('TNM')] cancer staging values, such as `'Tis'`, `'G3'` and so on, and uses them in a Boolean expression whose value is assigned to the variable `is_luminal_A`.

----
    func tnm_major_number (tnm_val: String): Integer

    is_luminal_A: Boolean := tnm_major_number ($tnm_t) < 3 and 
                             tnm_major_number ($tnm_n) < 2 and 
                             tnm_major_number ($tnm_g) < 3
----

A procedure is a routine with a signature of the form `<T_arg1, T_arg2, ....>`, i.e. a call taking 0 or more arguments, with no return type. Typical signatures include the following:

----
    -- NB: not EL syntax
    <Real>                          -- a 1st-order procedure for the domain R
    <String, Integer>               -- signature of a procedure taking a String and an Integer argument
----

Procedures must be declared before use. This is done using the same syntax as for functions, as in the following example.

----
    proc alert_user (message: String; priority: Integer)    -- a procedure that generates a user alert
----

Functions and procedures are mapped to class methods in external libraries in the <<_computing_bindings, Computing Bindings>> section of an EL text.

== Assignment

An assignment is a kind of statement used to assign the value of an expression to a writable variable using the `:=` operator. An assignment may be made in a local variable declaration in the same way as in many programming languages. The right hand side of an assignment is any value-returning expression. Typical assignments are illustrated below.

--------
definition
    speed_kmh: Real                             -- declaration
    speed_mph: Real := 35.0                     -- assignment in a declaration (not a constant)
        
    speed_kmh := speed_mph * Mph_to_kmh_factor  -- assignment
--------

The following shows an assignment with an expression using a function and an external variable.

----
data_context
    in $date_of_birth: Date
    
definition
    age: Duration
    age := current_date() - $date_of_birth
    ...
----

== Procedure Invocation

EL supports the invocation of procedures in the same way as for functions. Computationally both are the same, being invocations of class methods or other functions defined in bound libraries.

The following shows a typical procedure declaration and invocation.

----
    proc alert_user (message: String; priority: Integer)    -- a procedure that generates a user alert
    
    if $systolic_bp_meas > 180.0 then
        alert_user ([dangerous_blood_pressure], 1)          -- call the procedure
    end
----

== Control Structures

Two control structures are provided in EL. They provide conditional logic structures from which statements (i.e. assignments and procedure calls) can be executed. Control structures may be nested in the usual way.

=== If / then

In common with most programming languages, EL provides a standard 'if / then / elseif / else' structure, as follows:

----
data_context
    in $systolic_bp_meas: Real     -- from instrument
    in thyroid_t3: Real            -- from EHR

definition
    if $systolic_bp_meas > 160.0 then
        alert_user ([dangerous_blood_pressure], 1)
        
    elseif $systolic_bp_meas > 140.0 and thyroid_t3 > 200 then
        inform_user ([raised_bp_and_abnormal_thyroid_activity], 2)
        
    else
        -- other cases
    end
----

This structure is always evaluated in order.

=== When / then

EL provides a `when / matches / then` statement that is roughly equivalent to 'case' or 'switch' statements in most other languages. The `when` part indicates a  value-returning expression (such as a variable reference), which may be of any type, while the `matches` parts define value intervals that are used to match the `when` value. The first branch matched is executed.

the syntax is as follows.

--------
    when <expression>
        matches <value_interval_1> then
            -- statements
        matches <value_interval_2> then
            -- statements
            ...
        matches <value_interval_N> then
            -- statements
            
        else
            -- statements
    end
--------

The syntax for the match intervals is the standard EL Interval type literal syntax. An example 'when / then' statement is as follows:

--------
data_context
    in $systolic_bp_meas: Real     -- from instrument

definition
    when $systolic_bp_meas
        matches |>= 180.0| then
            alert ([dangerous_blood_pressure], 0)

        matches |>= 160.0| then
            alert ([high_blood_pressure], 1)
    end
--------
